---
description: Standards for Form Validation using Zod and Shadcn UI
globs: **/*.tsx
---

# Form Validation Standards

This document outlines the standard for implementing forms with Zod validation and Shadcn UI in the project.

## Core Principles

1.  **Inline Validation**: Validation errors must appear inline below the specific field that failed, using `FormMessage`.
2.  **No Toasts for Validation**: Do not use toast notifications for form validation errors unless it's a generic system error (e.g., Network Error 500).
3.  **Zod First**: All validation logic (required, min/max length, patterns) must be defined in the Zod schema.
4.  **Server-Side Error Mapping**: API errors should be mapped back to form fields whenever possible.

## Implementation Pattern

### 1. Define Zod Schema

Colocate the schema with the component or in a separate types file if reused.

```typescript
import * as z from 'zod'

export const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
})

export type LoginValues = z.infer<typeof loginSchema>
```

### 2. Component Structure

Use the `Form` wrapper from `shadcn/ui` and `react-hook-form`.

```tsx
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from '@/components/ui/Form'

export function LoginForm({ onSubmit }: { onSubmit: (values: LoginValues) => Promise<void> }) {
  const form = useForm<LoginValues>({
    resolver: zodResolver(loginSchema),
    defaultValues: { email: '', password: '' }
  })

  const handleSubmit = async (values: LoginValues) => {
    try {
      await onSubmit(values)
    } catch (error: any) {
      // Handle Server-Side Validation Errors
      if (error?.response?.data?.errors) {
        // Assuming API returns { errors: { email: "Email already taken" } }
        Object.entries(error.response.data.errors).forEach(([key, message]) => {
          form.setError(key as any, { type: 'manual', message: String(message) })
        })
      } else {
        // Fallback to global error
        form.setError('root', { message: error.message || 'Something went wrong' })
      }
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(handleSubmit)}>
        {/* Global/Root Error Message */}
        {form.formState.errors.root && (
          <div className="text-destructive text-sm mb-4">
            {form.formState.errors.root.message}
          </div>
        )}

        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage /> {/* <--- This renders the red error text */}
            </FormItem>
          )}
        />
        {/* Submit Button */}
      </form>
    </Form>
  )
}
```

## Do's and Don'ts

*   **DO** use `zodResolver` to connect Zod to React Hook Form.
*   **DO** ensure `<FormMessage />` is present for every field.
*   **DON'T** manually check values in `handleSubmit` (e.g., `if (!values.email) toast(...)`). Let Zod handle it.
*   **DON'T** catch errors in the parent component and show a toast if the error is specific to a field. Pass the error handling down or let the child handle the mapping.
