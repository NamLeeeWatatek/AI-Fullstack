// Patch file for multi-config support
// Apply these changes to apps/web/app/(dashboard)/channels/page.tsx

// ============================================
// 1. UPDATE INTERFACE (line 38-44)
// ============================================
// REPLACE:
interface IntegrationConfig {
    provider: string
    client_id: string
    client_secret: string
    scopes?: string
    is_active: boolean
}

// WITH:
interface IntegrationConfig {
    id: number
    name?: string
    provider: string
    client_id: string
    client_secret: string
    scopes?: string
    is_active: boolean
}

// ============================================
// 2. UPDATE STATE (line 47-58)
// ============================================
// REPLACE:
    const [configs, setConfigs] = useState<Record<string, IntegrationConfig>>({})
    const [loading, setLoading] = useState(true)
    const [connecting, setConnecting] = useState<string | null>(null)
    const [configuring, setConfiguring] = useState<string | null>(null)

    // Config Form State
    const [configForm, setConfigForm] = useState({
        client_id: '',
        client_secret: '',
        scopes: ''
    })

// WITH:
    const [configs, setConfigs] = useState<IntegrationConfig[]>([])
    const [loading, setLoading] = useState(true)
    const [connecting, setConnecting] = useState<string | null>(null)
    const [configuring, setConfiguring] = useState<number | null>(null)

    // Config Form State
    const [configForm, setConfigForm] = useState({
        id: null as number | null,
        provider: '',
        name: '',
        client_id: '',
        client_secret: '',
        scopes: ''
    })

// ============================================
// 3. UPDATE loadData (line 64-85)
// ============================================
// REPLACE:
    const loadData = async () => {
        try {
            setLoading(true)
            const [channelsData, configsData] = await Promise.all([
                fetchAPI('/channels/'),
                fetchAPI('/integrations/')
            ])
            setChannels(channelsData)

            // Map configs by provider
            const configMap: Record<string, IntegrationConfig> = {}
            configsData.forEach((c: IntegrationConfig) => {
                configMap[c.provider] = c
            })
            setConfigs(configMap)

        } catch (error) {
            console.error(error)
        } finally {
            setLoading(false)
        }
    }

// WITH:
    const loadData = async () => {
        try {
            setLoading(true)
            const [channelsData, configsData] = await Promise.all([
                fetchAPI('/channels/'),
                fetchAPI('/integrations/')
            ])
            setChannels(channelsData)
            setConfigs(configsData)

        } catch (error) {
            console.error(error)
        } finally {
            setLoading(false)
        }
    }

// ============================================
// 4. UPDATE handleConnect (line 87-143)
// ============================================
// REPLACE:
    const handleConnect = async (provider: string) => {
        // Check if configured
        if (!configs[provider]?.client_id) {
            toast.error(`Please configure ${provider} settings first`)
            openConfig(provider)
            return
        }

        try {
            setConnecting(provider)

            // Get OAuth URL
            const { url } = await fetchAPI(`/oauth/login/${provider}`)

// WITH:
    const handleConnect = async (provider: string, configId?: number) => {
        // Check if configured
        const config = configId ? configs.find(c => c.id === configId) : configs.find(c => c.provider === provider)
        if (!config) {
            toast.error(`Please configure ${provider} settings first`)
            openConfig(undefined, provider)
            return
        }

        try {
            setConnecting(provider)

            // Get OAuth URL
            const configParam = configId ? `?configId=${configId}` : ''
            const { url } = await fetchAPI(`/oauth/login/${provider}${configParam}`)

// ============================================
// 5. UPDATE openConfig (line 163-171)
// ============================================
// REPLACE:
    const openConfig = (provider: string) => {
        const existing = configs[provider]
        setConfigForm({
            client_id: existing?.client_id || '',
            client_secret: existing?.client_secret || '',
            scopes: existing?.scopes || ''
        })
        setConfiguring(provider)
    }

// WITH:
    const openConfig = (configId?: number, provider?: string) => {
        const existing = configId ? configs.find(c => c.id === configId) : null
        setConfigForm({
            id: existing?.id || null,
            provider: existing?.provider || provider || '',
            name: existing?.name || '',
            client_id: existing?.client_id || '',
            client_secret: existing?.client_secret || '',
            scopes: existing?.scopes || ''
        })
        setConfiguring(configId || null)
    }

// ============================================
// 6. UPDATE saveConfig (line 173-190)
// ============================================
// REPLACE:
    const saveConfig = async () => {
        if (!configuring) return

        try {
            await fetchAPI('/integrations/', {
                method: 'POST',
                body: JSON.stringify({
                    provider: configuring,
                    ...configForm
                })
            })
            toast.success('Configuration saved')
            setConfiguring(null)
            loadData()
        } catch {
            toast.error('Failed to save configuration')
        }
    }

// WITH:
    const saveConfig = async () => {
        if (!configForm.provider) {
            toast.error('Provider is required')
            return
        }

        try {
            const method = configForm.id ? 'PUT' : 'POST'
            const url = configForm.id ? `/integrations/${configForm.id}` : '/integrations/'
            
            await fetchAPI(url, {
                method,
                body: JSON.stringify({
                    provider: configForm.provider,
                    name: configForm.name,
                    clientId: configForm.client_id,
                    clientSecret: configForm.client_secret,
                    scopes: configForm.scopes,
                    isActive: true
                })
            })
            toast.success('Configuration saved')
            setConfiguring(null)
            loadData()
        } catch {
            toast.error('Failed to save configuration')
        }
    }

// ============================================
// 7. UPDATE configuredCount (around line 295)
// ============================================
// REPLACE:
    const configuredCount = Object.keys(configs).length

// WITH:
    const configuredCount = configs.length

// ============================================
// 8. UPDATE configuredNotConnected (around line 299)
// ============================================
// REPLACE:
    const configuredNotConnected = Object.keys(configs).filter(provider =>
        !channels.some(c => c.type === provider)
    )

// WITH:
    const configuredProviders = new Set(configs.map(c => c.provider))
    const configuredNotConnected = Array.from(configuredProviders).filter(provider =>
        !channels.some(c => c.type === provider)
    )

// ============================================
// 9. UPDATE notConfigured (around line 302)
// ============================================
// REPLACE:
    const notConfigured = allChannels.filter(ch =>
        !configs[ch.id] && !channels.some(c => c.type === ch.id)
    )

// WITH:
    const notConfigured = allChannels.filter(ch =>
        !configuredProviders.has(ch.id) && !channels.some(c => c.type === ch.id)
    )

// ============================================
// NOTES:
// ============================================
// - Backend đã sẵn sàng hỗ trợ multiple configs
// - Các thay đổi này cho phép frontend làm việc với array of configs
// - Modal và các UI components khác sẽ tự động hoạt động với state mới
